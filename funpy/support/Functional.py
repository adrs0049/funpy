#!/usr/bin/python
# -*- coding: utf-8 -*-
# Author: Andreas Buttenschoen
import numpy as np

from ..fun import Fun
from ..cheb import polyval
from ..cheb import computeDerCoeffs


class Functional:
    """ Implements a functional in a Hilbert space, which by Riesz is generated by an element in the
        Hilbert space via the inner product. The inner product on cartesian product Hilbert spaces
        is implemented in the canonical way.
    """
    def __init__(self, f, *args, **kwargs):
        # type of functional
        self.basis = kwargs.pop('basis', 'coeff')
        self.dorder = kwargs.pop('order', 0)
        # TODO: fix the naming of the "basis eventually!
        assert self.basis in ['coeff', 'value', 'trigspec', 'trigval', 'real'], 'Basis of the functional must be \'coeff\' or \'value\''

        # Domain rescale factor!
        rescaleFactor = 0.5 * np.diff(f.domain)

        # store shape
        self.shape = f.shape

        # transform the value of f(x) to coefficient representation
        if self.basis == 'coeff':
            from cheb.chebpts import quadwts
            self.rhs = np.empty(self.dorder + 1, dtype=object)
            self.diff = self.diff_cheb

            for order in range(self.dorder + 1):
                rhs = np.empty(f.m, dtype=object)

                # get the integration weights
                w = quadwts(f.n)

                # iterate over the columns of f
                for j, col in enumerate(f):
                    rhs[j] = np.rot90(polyval(np.rot90(w * col.values.T)), -1)
                self.rhs[order] = np.hstack(rhs) * rescaleFactor

                # Differentiate - the factor is already taking care of the scaling required for the
                # second term in the inner product!
                if order < self.dorder:
                    f = (np.diff(f) / rescaleFactor).prolong(max(1, f.n-1))

        elif self.basis == 'trigspec':
            from trig.trigpts import quadwts
            self.rhs = np.empty(self.dorder + 1, dtype=object)
            self.diff = self.diff_trig

            for order in range(self.dorder + 1):
                rhs = np.empty(f.m, dtype=object)

                # For trigonometric polynomials we can easily show that functionals
                # or equivalently inner products (in L2) surmount to doing the following
                # computation.
                #
                #                    1
                # Int[f, g] e = ∑ ∑  ∫ e^{i pi k x} e^{- i pi j x} dx
                #               k j -1
                #
                # Since the exp(i k pi x) form a ONB on [-1, 1] we have that
                #
                #                     ___
                # Int[f, g] = 2 ∑ c_k d_k
                #               k
                #
                # where c_k are the Fourier coefficients for f(x), and d_k are the
                # Fourier coefficients for g(x).

                # iterate over the columns of f
                for j, col in enumerate(f):
                    rhs[j] = 2. * rescaleFactor * np.conj(col.coeffs.flatten(order='F'))

                # Store the functionals row-vector
                self.rhs[order] = np.hstack(rhs)

                # Differentiate - the factor is already taking care of the scaling required for the
                # second term in the inner product!
                f = np.diff(f) / rescaleFactor

        elif self.basis == 'trigval':
            return NotImplemented
        elif self.basis == 'real':
            # Use the standard inner-product in Rn
            rhs = np.empty(f.m, dtype=object)
            # iterate over the columns of f
            for j, col in enumerate(f):
                rhs[j] = col.values.T
            self.rhs = np.hstack(rhs)
        else:
            w = quadwts(f.n)
            assert self.dorder == 0, 'Non-zero dorder not implemented!'
            rhs = np.empty(f.m, dtype=object)
            # iterate over the columns of f
            for j, col in enumerate(f):
                rhs[j] = w * col.values.T
            self.rhs = np.hstack(rhs) * rescaleFactor

    def diff_cheb(self, c):
        return computeDerCoeffs(c)

    def diff_trig(self, c):
        # TODO move this somewhere better!
        n = c.shape[0]

        if n & 1:
            waveNumber = np.expand_dims(np.arange(-(n-1)/2, n/2), axis=1)
        else:
            waveNumber = np.expand_dims(np.arange(-n/2, n/2), axis=1)

        # derivative in Fourier space
        return c * (1j * np.pi * waveNumber)

    def __call__(self, u):
        """ Implements (f, u) """
        coeffs = u.coeffs if isinstance(u, Fun) else u.reshape(self.shape)
        iproduct = np.dot(self.rhs[0], coeffs.flatten(order='F'))

        for order in range(self.dorder):
            # Skip constant functions
            if coeffs.shape[0] == 1:
                continue

            coeffs = self.diff(coeffs)
            iproduct += np.dot(self.rhs[order+1], coeffs.flatten(order='F'))

        return iproduct
